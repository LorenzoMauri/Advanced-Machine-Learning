# Advanced Machine Learning
-------------------------------------------------------------------------------------------------------------------------------------------------------
### Image auto-orientation

Dataset: to be generated by the students

• Task: 4 classes. Classify if an image is correctly oriented (0°) or not
(affected by 90°, 180° or 270° orientation)


## Drive directories structure

-- AML project 2021-2-F1801Q151
  |-- datasets
      |-- indoor-scenes-cvpr-2019
      |-- SUN397 
  |-- models 
  |-- papers 

### Dataset
Per la risoluzione del problema è necessario un dataset misto, composto cioè da immagini generiche di ambienti sia chiusi che aperti. A tal proposito vengono considerati i seguenti dataset e poi uniti tramite specifiche tecniche.

* SUN397  : ottenuto dal sito ufficiale : https://vision.princeton.edu/projects/2010/SUN/ 
* INDOOR : ottenuto dal sito ufficiale  https://web.mit.edu/torralba/www/indoor.html  

Data PreProcessing : 
Le immagini vengono dapprima ruotate di 90,180 e 270 gradi con un resizing a 224x224 (dimensione di input dei classificatori). Inoltre in questo modo è possibile ridurre la dimensione complessiva di ogni dataset .

#### INDOOR
Vengono generati i file presenti in Drive nella corrispondente cartella INDOOR
* rotatedImages.tar 
* rotatedImages.tar

#### SUN
Sono presenti 10 partizioni ufficiali : consideriamo solo la prima (approx 13 GB da dividere per 4 classi) 
Vengono generati i file presenti in Drive nella corrispondente cartella SUN

* rotatedImages.tar 
* rotatedImages.tar


nb. In questo caso viene effettuato il download del dataset e per comodità elaborato in locale per poi essere caricato sul Drive e quindi usato in Colab.

NO resizing 224x224



## Implementazione del modello
### CURRENT STATE
Fase di sperimentazione.
Decidiamo di iniziare provando ad effettuare Transfer Learning . I modelli pre-allenati (sul dataset Imagenet) presi in considerazione sono i seguenti :


* Vgg16
* Mobilenet v2 -  partire da file colab "shared"
* Xception


Vengono mantenuti fissi tutti i layer e allenato solo l'ultimo (fully connected con unità = 4 ) . Nel caso di overfitting si aggiunge un layer di regolarizzazione Dropout con prob = 0.5 .


inputs = tf.keras.Input(shape = IMAGE_SIZE + (3, ))  # channels_last data format
x = base_model(inputs, training = False)
#x = tf.keras.layers.GlobalAveragePooling2D()(x)
x = tf.keras.layers.Dropout(0.5)(x) # to prevent overfitting
outputs = tf.keras.layers.Dense(num_classes)(x)
model = tf.keras.Model(inputs, outputs)





### Confronto 
Per confrontare i risultati derivanti dai diversi modelli ci limitiamo per il momento a osservare le metriche delle prime 5 epoch in fase di validazione.



